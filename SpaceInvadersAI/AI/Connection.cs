using SpaceInvadersAI.AI.Cells;
using SpaceInvadersAI.AI.Utilities;
using System.Text;

namespace SpaceInvadersAI.AI;

/// <summary>
/// Represents a neural connection between two cells.
/// </summary>
internal class Connection
{
    //   ███     ███    █   █   █   █   █████    ███    █████    ███     ███    █   █
    //  █   █   █   █   █   █   █   █   █       █   █     █       █     █   █   █   █
    //  █       █   █   ██  █   ██  █   █       █         █       █     █   █   ██  █
    //  █       █   █   █ █ █   █ █ █   ████    █         █       █     █   █   █ █ █
    //  █       █   █   █  ██   █  ██   █       █         █       █     █   █   █  ██
    //  █   █   █   █   █   █   █   █   █       █   █     █       █     █   █   █   █
    //   ███     ███    █   █   █   █   █████    ███      █      ███     ███    █   █

    /// <summary>
    /// Id of the cell the connection is from.
    /// </summary>
    internal string From;

    /// <summary>
    /// Id of the cell the connection is to.
    /// </summary>
    internal string To;

    internal int ToNeuronIndex;
    internal int FromNeuronIndex;

    /// <summary>
    /// The weight of the connection. (How much it affects the cell it's connected to.)
    /// </summary>
    internal double Weight;

    /// <summary>
    /// Returns the DNA of the connection.
    /// </summary>
    internal int DNA
    {
        get
        {
            return (From + "~" + To + "~" + Weight.ToString()).GetHashCode();
        }
    }

    /// <summary>
    /// Create a connection with specific weight.
    /// </summary>
    /// <param name="from"></param>
    /// <param name="to"></param>
    /// <param name="weight"></param>
    internal Connection(string from, string to, double weight)
    {
        From = from;
        To = to;
        Weight = weight;
    }

    /// <summary>
    /// Create a connection with random weight.
    /// </summary>
    /// <param name="from"></param>
    /// <param name="to"></param>
    /// <param name="weight"></param>
    internal Connection(BaseCell from, BaseCell to)
    {
        From = from.Id;
        To = to.Id;
        Weight = Utils.RandomNumberPlusOrMinus1();
    }

    /// <summary>
    /// Used to track connections.
    /// </summary>
    internal string KeyFromTo
    {
        get
        {
            return ComputeKey(From, To);
        }
    }

    /// <summary>
    /// Used to track connections.
    /// </summary>
    internal string KeyToFrom
    {
        get
        {
            return ComputeKey(To, From);
        }
    }

    /// <summary>
    /// Used to track connections.
    /// "{from}-{to}"
    /// </summary>
    internal static string ComputeKey(string fromId, string toId)
    {
        StringBuilder sb = new(3);

        sb.Append(fromId);
        sb.Append('~');
        sb.Append(toId);

        return sb.ToString();
    }

    /// <summary>
    /// Used to track connections.
    /// </summary>
    /// <param name="key"></param>
    /// <param name="fromId"></param>
    /// <param name="toId"></param>
    /// <exception cref="ArgumentOutOfRangeException"></exception>
    internal static void GetIDsFromKey(string key, out string fromId, out string toId)
    {
        // "{from}-{to}"
        string[] tokens = key.Split('~');

        if (tokens.Length != 2) throw new ArgumentOutOfRangeException(nameof(key), "malformed key - should have been generated by ComputeKey()");

        fromId = tokens[0];
        toId = tokens[1];
    }

    /// <summary>
    /// Override to provide meaningful debug.
    /// </summary>
    /// <returns></returns>
    public override string? ToString()
    {
        return $"From: \"{From}\" To: \"{To}\" Weight: {Weight:0.#######}";
    }

    /// <summary>
    /// Connections are limited in mutation approach. They only have their id's, and weight.
    /// </summary>
    /// <param name="mutationMethod"></param>
    internal virtual void Mutate(MutationMethod mutationMethod)
    {
        switch (mutationMethod)
        {
            case MutationMethod.ModifyWeight:
                {
                    Weight += Utils.RandomPlusMinusRange(RarelyModifiedSettings.MutationCellWeightMinDelta, RarelyModifiedSettings.MutationCellWeightMaxDelta);
                    break;
                }

            default:
                break; // do not add exception here, as this method can be overridden
        }
    }

    /// <summary>
    /// Serialises the connection to a string.
    /// </summary>
    /// <returns></returns>
    internal string Serialise()
    {
        return $"ADD CONNECTION FROM=\"{From}\" TO=\"{To}\" WEIGHT={Weight}";
    }

    /// <summary>
    /// De-serialises the connection from a string, attaching to a network.
    /// It is the reverse of Serialise().
    /// </summary>
    /// <param name="neuralNetwork"></param>
    /// <param name="lineOfTextToDeserialise"></param>
    /// <returns></returns>
    internal static Connection Deserialise(NeuralNetwork neuralNetwork, string lineOfTextToDeserialise)
    {
        lineOfTextToDeserialise = lineOfTextToDeserialise.Trim().Replace("ADD CONNECTION ", "");

        // parses the tokens
        Dictionary<string, string> tokens = Utils.RegExpParseTokens(lineOfTextToDeserialise);

        // these return "undefined" if missing
        string from = Utils.SafeGetAttribute(tokens, "FROM");
        string to = Utils.SafeGetAttribute(tokens, "TO");
        string weight = Utils.SafeGetAttribute(tokens, "WEIGHT");

        // VALIDATE THE INPUTS

        if (from == "undefined" || !neuralNetwork.Neurons.ContainsKey(from))
        {
            throw new ArgumentOutOfRangeException(nameof(lineOfTextToDeserialise), "cellFrom is invalid, it does not exist in the network");
        }

        if (to == "undefined" || !neuralNetwork.Neurons.ContainsKey(to))
        {
            throw new ArgumentOutOfRangeException(nameof(lineOfTextToDeserialise), "cellTo is invalid, it does not exist in the network");
        }

        if (weight == "undefined" || !double.TryParse(weight, out double weightValue))
        {
            throw new ArgumentOutOfRangeException(nameof(lineOfTextToDeserialise), "weight is invalid, it is not a double.");
        }

        // ALL GOOD, CREATE THE CONNECTION

        return new Connection(neuralNetwork.Neurons[from].Id, neuralNetwork.Neurons[to].Id, weightValue);
    }
}